"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[240],{5886:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"introduction/concepts","title":"Kafka Concepts","description":"A few of the Kafka concepts are abstracted away in this framework and this page attempts to clarify those concepts.","source":"@site/docs/introduction/concepts.md","sourceDirName":"introduction","slug":"/introduction/concepts","permalink":"/kp/docs/introduction/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/honestbank/kp/edit/main/docs/docs/introduction/concepts.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Configuration Options","permalink":"/kp/docs/introduction/configuration"},"next":{"title":"Schema Registry","permalink":"/kp/docs/introduction/schema-registry"}}');var i=o(4848),n=o(8453);const a={sidebar_position:4},r="Kafka Concepts",c={},d=[{value:"Partitions",id:"partitions",level:2},{value:"Offsets",id:"offsets",level:2},{value:"Consumer Groups",id:"consumer-groups",level:2},{value:"Replication",id:"replication",level:2},{value:"Zookeeper",id:"zookeeper",level:2}];function l(e){const t={admonition:"admonition",h1:"h1",h2:"h2",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"kafka-concepts",children:"Kafka Concepts"})}),"\n",(0,i.jsx)(t.p,{children:"A few of the Kafka concepts are abstracted away in this framework and this page attempts to clarify those concepts."}),"\n",(0,i.jsx)(t.h2,{id:"partitions",children:"Partitions"}),"\n",(0,i.jsx)(t.p,{children:"In Kafka, a topic is divided into one or more partitions, which allow the topic to scale horizontally. Each partition is an ordered, immutable sequence of messages that is continually appended to."}),"\n",(0,i.jsx)(t.p,{children:"Producers can specify which partition to write to, allowing them to control the distribution of messages within a topic. If no partition is specified, the producer will use a default partitioning strategy, such as a round-robin approach."}),"\n",(0,i.jsx)(t.p,{children:"Consumers can also specify which partitions to read from, allowing them to distribute the workload of reading and processing messages across multiple consumer instances."}),"\n",(0,i.jsx)(t.h2,{id:"offsets",children:"Offsets"}),"\n",(0,i.jsx)(t.p,{children:"Offsets are used to track the position of a consumer within a partition. Each time a consumer reads a message from a partition, it advances its offset by one. This allows the consumer to know which message to read next and enables Kafka to track the progress of the consumer."}),"\n",(0,i.jsx)(t.p,{children:"Offsets can be committed by the consumer, allowing it to resume reading from the last committed offset if it is restarted or if there is a failure."}),"\n",(0,i.jsx)(t.h2,{id:"consumer-groups",children:"Consumer Groups"}),"\n",(0,i.jsx)(t.p,{children:"In Kafka, a consumer group is a set of consumer instances that work together to read and process messages from a topic. Each consumer in the group is assigned a set of partitions to read from, and the group works together to load balance the work of reading and processing the messages across all of its members."}),"\n",(0,i.jsx)(t.p,{children:"If a consumer fails or is restarted, the consumer group will automatically reassign the partitions to another member to ensure that the messages are still being processed. This enables consumer groups to provide fault tolerance and allows for easy scaling of message processing."}),"\n",(0,i.jsx)(t.h2,{id:"replication",children:"Replication"}),"\n",(0,i.jsx)(t.p,{children:"Kafka allows for the replication of messages within a topic across multiple brokers. This ensures that the messages are highly available and can be recovered in the event of a broker failure."}),"\n",(0,i.jsx)(t.p,{children:"Replication also allows for the use of multiple consumer groups to read from the same topic, allowing for parallel processing of the messages."}),"\n",(0,i.jsx)(t.h2,{id:"zookeeper",children:"Zookeeper"}),"\n",(0,i.jsx)(t.p,{children:"Zookeeper is a distributed coordination service that is used by Kafka to store metadata about the Kafka cluster and manage the distributed nature of the Kafka brokers."}),"\n",(0,i.jsx)(t.p,{children:"Zookeeper is responsible for maintaining the state of the Kafka cluster, including the list of brokers, the topics that exist, the consumer groups that are active, and the consumer group assignments for each partition."}),"\n",(0,i.jsx)(t.p,{children:"Kafka relies on Zookeeper to manage the distributed nature of the cluster and enable consumers and producers to discover and communicate with the brokers."}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsx)(t.p,{children:"KP disables autocommit and commits each message once they're finished processing.\nThis way we'll always wait for a message to complete processing (failing or succeeding) before committing."})})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>r});var s=o(6540);const i={},n=s.createContext(i);function a(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);