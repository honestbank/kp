"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[931],{6091:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"middlewares/order-of-middleware","title":"order-of-middleware","description":"Order of Middleware Execution","source":"@site/docs/middlewares/order-of-middleware.md","sourceDirName":"middlewares","slug":"/middlewares/order-of-middleware","permalink":"/kp/docs/middlewares/order-of-middleware","draft":false,"unlisted":false,"editUrl":"https://github.com/honestbank/kp/edit/main/docs/docs/middlewares/order-of-middleware.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/kp/docs/middlewares/introduction"},"next":{"title":"Consumer","permalink":"/kp/docs/middlewares/consumer"}}');var d=i(4848),s=i(8453);const t={sidebar_position:2},l=void 0,o={},a=[{value:"Order of Middleware Execution",id:"order-of-middleware-execution",level:3},{value:"Step-by-step Flow of Execution",id:"step-by-step-flow-of-execution",level:4},{value:"Execution Example",id:"execution-example",level:4},{value:"Key Characteristics",id:"key-characteristics",level:4},{value:"Usage",id:"usage",level:3},{value:"Summary",id:"summary",level:4}];function c(e){const r={code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(r.h3,{id:"order-of-middleware-execution",children:"Order of Middleware Execution"}),"\n",(0,d.jsxs)(r.p,{children:["The middleware system implemented in the code follows a ",(0,d.jsx)(r.strong,{children:"stack-based execution model"}),". Middleware functions are executed in the order they are added, which means that the first middleware added is the first one to execute. However, due to the nature of how the middleware system works, the control flow unwinds in reverse order after processing, allowing each middleware to perform actions both ",(0,d.jsx)(r.strong,{children:"before"})," and ",(0,d.jsx)(r.strong,{children:"after"})," the next middleware in the stack."]}),"\n",(0,d.jsx)(r.h4,{id:"step-by-step-flow-of-execution",children:"Step-by-step Flow of Execution"}),"\n",(0,d.jsx)(r.p,{children:"Let's consider a sample code to show 3 middleware added in order: A, B, C which might look something like below."}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-go",children:'package main\n\nimport "context"\n\ntype Middleware[T any] struct {\n\tName string\n}\n\nfunc (m Middleware[T]) Process(ctx context.Context, item T, next func(ctx context.Context, item T) error) error {\n\tprintln("Middleware " + m.Name + " -> before logic")\n\terr := next(ctx, item)\n\tprintln("Middleware " + m.Name + " -> before logic")\n\n\treturn err\n}\nfunc main() {\n   kp := v2.New[string]()\n   middlewareA := Middleware[string]{Name: "A"}\n   middlewareB := Middleware[string]{Name: "B"}\n   middlewareC := Middleware[string]{Name: "C"}\n   kp.AddMiddleware(middlewareA)\n   kp.AddMiddleware(middlewareB)\n   kp.AddMiddleware(middlewareC)\n}\n'})}),"\n",(0,d.jsxs)(r.ol,{children:["\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"Adding Middleware"}),":"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["Middleware is added to the processor using the ",(0,d.jsx)(r.code,{children:"AddMiddleware"})," method. The order in which you add middleware determines the execution order."]}),"\n",(0,d.jsxs)(r.li,{children:["For example, if you add middleware in this order: ",(0,d.jsx)(r.code,{children:"MiddlewareA"}),", ",(0,d.jsx)(r.code,{children:"MiddlewareB"}),", and ",(0,d.jsx)(r.code,{children:"MiddlewareC"}),", they will be executed in the same sequence."]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"Processing the Middleware Stack"}),":"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["When the ",(0,d.jsx)(r.code,{children:"Process"})," method is called, the middleware functions are executed in the order they were added. The first middleware in the list is executed first."]}),"\n",(0,d.jsxs)(r.li,{children:["During the execution of each middleware, the control is passed to the next middleware using the ",(0,d.jsx)(r.code,{children:"next"})," function, which recursively processes each middleware until the end of the list is reached."]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"Control Flow"}),":"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["Each middleware gets the opportunity to perform operations ",(0,d.jsx)(r.strong,{children:"before"})," and ",(0,d.jsx)(r.strong,{children:"after"})," the next middleware in the chain. This means that while the middleware chain is called in the order of addition, the response unwinds in reverse order."]}),"\n",(0,d.jsxs)(r.li,{children:["For example, if ",(0,d.jsx)(r.code,{children:"MiddlewareA"}),", ",(0,d.jsx)(r.code,{children:"MiddlewareB"}),", and ",(0,d.jsx)(r.code,{children:"MiddlewareC"})," were added to the processor, the order of execution would look like this:","\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{children:"1. MiddlewareA -> before logic\n2. MiddlewareB -> before logic\n3. MiddlewareC -> before logic\n4. MiddlewareC -> after logic\n5. MiddlewareB -> after logic\n6. MiddlewareA -> after logic\n"})}),"\n"]}),"\n",(0,d.jsx)(r.li,{children:"This pattern allows each middleware to wrap around the behavior of the next one in the chain, making it possible to perform actions both before and after the core logic of the middleware stack."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(r.h4,{id:"execution-example",children:"Execution Example"}),"\n",(0,d.jsxs)(r.p,{children:["Let's say we have three middleware components: ",(0,d.jsx)(r.code,{children:"MiddlewareA"}),", ",(0,d.jsx)(r.code,{children:"MiddlewareB"}),", and ",(0,d.jsx)(r.code,{children:"MiddlewareC"}),". The following sequence of events will occur:"]}),"\n",(0,d.jsxs)(r.ol,{children:["\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"Before Execution Phase"}),":"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"MiddlewareA"}),' is called first. It performs its "before" logic.']}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"MiddlewareA"})," calls the next middleware in the stack, which is ",(0,d.jsx)(r.code,{children:"MiddlewareB"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"MiddlewareB"}),' performs its "before" logic and then calls ',(0,d.jsx)(r.code,{children:"MiddlewareC"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"MiddlewareC"}),' performs its "before" logic. Since it\'s the last middleware, it reaches the core logic or the final result.']}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(r.li,{children:["\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.strong,{children:"After Execution Phase"}),":"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["After ",(0,d.jsx)(r.code,{children:"MiddlewareC"})," completes its process, it returns control back to ",(0,d.jsx)(r.code,{children:"MiddlewareB"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"MiddlewareB"}),' now performs its "after" logic and returns control to ',(0,d.jsx)(r.code,{children:"MiddlewareA"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:["Finally, ",(0,d.jsx)(r.code,{children:"MiddlewareA"}),' performs its "after" logic.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(r.p,{children:"This pattern allows for a clean and structured way to handle pre-processing and post-processing in a middleware chain."}),"\n",(0,d.jsx)(r.h4,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"Forward Execution"}),": Middleware is executed in the order it is added."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"Reverse Unwinding"}),": Once a middleware finishes its operation, control is returned to the previous middleware, allowing it to complete any after-execution logic."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"Flexible Processing"}),": Middleware can modify the request, the response, or even handle errors in a centralized way."]}),"\n"]}),"\n",(0,d.jsxs)(r.p,{children:["This approach allows middleware authors to easily implement logic that needs to occur both ",(0,d.jsx)(r.strong,{children:"before"})," and ",(0,d.jsx)(r.strong,{children:"after"})," the main processing logic, creating a powerful mechanism for handling cross-cutting concerns like logging, authentication, error handling, and more."]}),"\n",(0,d.jsx)(r.h3,{id:"usage",children:"Usage"}),"\n",(0,d.jsx)(r.p,{children:"There are many middleware that make use of this pattern in KP."}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsx)(r.li,{children:"Consumer middleware retrieves an item from kafka and adds it in. (before logic)"}),"\n",(0,d.jsx)(r.li,{children:"Deadletter middleware evaluates the result and determines if the message should go to deadletter instead (after logic)"}),"\n",(0,d.jsx)(r.li,{children:"Backoff middleware delays execution and decreases or increases the interval for the next process (both before and after logic)"}),"\n",(0,d.jsx)(r.li,{children:"Gracefulshutdown middleware doesn't have before or after logic, it simply stops the execution flow"}),"\n",(0,d.jsx)(r.li,{children:"Measurement middleware starts a timer in before logic and measures the time taken in after logic."}),"\n",(0,d.jsx)(r.li,{children:"Retry middleware is same as deadletter (after logic)"}),"\n",(0,d.jsx)(r.li,{children:"RetryCount middleware injects the retry count header onto context (before logic)"}),"\n",(0,d.jsx)(r.li,{children:"Tracing middleware starts a span before and ends the span after (both before and after logic)"}),"\n",(0,d.jsx)(r.li,{children:"You might have a custom middleware that might make use of any of the above pattern."}),"\n"]}),"\n",(0,d.jsx)(r.h4,{id:"summary",children:"Summary"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"Order of execution"})," is ",(0,d.jsx)(r.strong,{children:"in the order middleware is added"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"Order of unwinding"})," is ",(0,d.jsx)(r.strong,{children:"in reverse order"}),"."]}),"\n",(0,d.jsxs)(r.li,{children:["This enables middleware to do processing ",(0,d.jsx)(r.strong,{children:"before"})," and ",(0,d.jsx)(r.strong,{children:"after"})," the next middleware in the chain."]}),"\n"]}),"\n",(0,d.jsx)(r.p,{children:"Understanding this order of execution is crucial for correctly implementing middleware logic, as it allows for both sequential processing and reverse unwinding for post-processing."})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,d.jsx)(r,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}},8453:(e,r,i)=>{i.d(r,{R:()=>t,x:()=>l});var n=i(6540);const d={},s=n.createContext(d);function t(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:t(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);